
<p class=" text-justify drop-cap">Storing your secrets in plain text is Bad Idea whether it’s your <a href="https://en.wikipedia.org/wiki/Vogon#Poetry" class=" article-link">Vogon Poetry</a> or your e-mail credentials. Depending on your level of paranoia (it’s not paranoia if they really <em>are</em> watching you…) the advice in this article may not be enough; but for most, though, keeping your secrets encrypted on your file system is an easy way of keeping your secrets secret.</p><p class=" text-justify">Emacs, obviously, can do this for you, and in a variety of ways.</p><p class=" text-justify">This article will teach you how to use Emacs’s native support for GnuPG – a package called EasyPG, or <code>epa</code> – to both sign/verify and encrypt/decrypt files, and how you can use this knowledge to store secrets that Emacs can understand. I will also show you how to use the <code>auth-source</code> package – a unified interface for different secrets backends – and how you can use it to automatically log in to various external services with public-private keys.</p><H2 id="keeping-secrets-in-emacs-with-gnupg-easypg">Keeping Secrets in Emacs with GnuPG &amp; EasyPG</H2><p class=" text-justify">GNU Privacy Guard (<a href="https://www.gnupg.org/" class=" article-link">GnuPG</a>) is a powerful tool and a free implementation of the OpenPGP standard. It’s especially useful for both symmetric and asymmetric cryptography: whether you are signing binaries or archives; encrypting or decrypting files with keys; or merely symmetrically encrypting them with a pass phrase, <em>GPG</em> is simply a great tool to have around.</p><p class=" text-justify">But GnuPG is also useful in Emacs. Emacs – as you would expect – has integrated support for basic GnuPG features through a built-in package called <em>EasyPG</em>.</p><p class=" text-justify">With <em>EasyPG</em> you can both sign and verify files, and encrypt and decrypt them, both symmetrically with passphrases and asymmetrically with public-private keys.</p><H3 id="gpg-v1-versus-gpg-v2">GPG v1 versus GPG v2</H3><p class=" text-justify">You may find that <code>gpg</code> cannot be found on your computer. This often happens as there is also a GPG version 2 named, aptly, <code>gpg2</code>. You can customize the <code>epg-gpg-program</code> variable to the name of the tool you want Emacs to use:</p><pre><code>(setq epg-gpg-program "gpg2")</code></pre><H4 id="transparent-file-cryptography-with-easypg">Transparent File Cryptography with EasyPG</H4><p class=" text-justify">One of the nicest features of Emacs’s GnuPG support is that it transparently decrypts and re-encrypts files you open and save in Emacs.</p><p class=" text-justify">The <em>EasyPG</em> package hooks into Emacs and will, transparently, detect GnuPG files. The variable <code>auto-mode-alist</code> controls how Emacs assigns major modes when you open certain files; in this instance, any file that ends with <code>.gpg</code> is treated as a GnuPG file in Emacs.</p><p class=" text-justify">To test it out, open a file – such as <code>/tmp/foobar.gpg</code> – write some text and then save it with <code>C-x C-s</code>. Emacs will prompt you for a key (if you have any) or, if you don’t pick one, a pass phrase to symmetrically encrypt the file with.</p><p class=" text-justify">If you then re-open it, you will be prompted for the same pass phrase and Emacs will decrypt it and open it.</p><p class=" text-justify">The possibilities are endless. And, of course, you can nest the file extensions: Open a <code>.py.gpg</code> file and it is first decrypted and <em>then</em> the normal <code>python-mode</code> machinery kicks in. The same with encrypted, compressed archives: open a <code>.tar.gz.gpg</code> file and Emacs will decrypt and then open it with <code>auto-compression-mode</code>.</p><H3 id="interactive-commands">Interactive Commands</H3><p class=" text-justify">There are a handful of interactive commands that help you use EasyPG:</p><table class=" table"><col style="width: 38%"><col style="width: 22%"><tbody><tr class="odd"><td style="text-align: left;"><strong>Command</strong></td><td style="text-align: left;"><strong>Description</strong></td></tr><tr class="even"><td style="text-align: left;"><p class=" text-justify"><code>M-x epa-list-keys</code></p><p class=" text-justify"><code>M-x epa-list-secret-keys</code></p></td><td style="text-align: left;">List all the keys from the public/secret keyring</td></tr><tr class="odd"><td style="text-align: left;"><code>M-x epa-verify-&lt;region|file&gt;</code></td><td style="text-align: left;">Verifies the current region/file</td></tr><tr class="even"><td style="text-align: left;"><code>M-x epa-sign-&lt;region|file&gt;</code></td><td style="text-align: left;">Signs the current region/file</td></tr><tr class="odd"><td style="text-align: left;"><code>M-x epa-insert-keys</code></td><td style="text-align: left;">Insert one or more keys into the buffer</td></tr><tr class="even"><td style="text-align: left;"><code>M-x epa-decrypt-&lt;region|file&gt;</code></td><td style="text-align: left;">Decrypts the current region/file</td></tr><tr class="odd"><td style="text-align: left;"><code>M-x epa-encrypt-&lt;region|file&gt;</code></td><td style="text-align: left;">Encrypts the current region/file</td></tr></tbody></table><p class=" text-justify">Most are variations of the same theme and don’t require further explaining. Both <code>M-x epa-list-keys</code> and <code>M-x epa-list-secret-keys</code> list keys in your system’s keychains. You can also browse them with the <em>Emacs Secrets</em> package (see chapter below) or a tool that ships with your system such as Ubuntu’s <code>seahorse</code>.</p><H3 id="dired">Dired</H3><p class=" text-justify">Thanks to the clever <code>auto-mode-alist</code> system you can open <code>.gpg</code> files in Dired as you would elsewhere. But Dired also comes with a couple of handy key bindings for interacting with <em>EasyPG</em>:</p><table class=" table"><col style="width: 22%"><col style="width: 22%"><tbody><tr class="odd"><td style="text-align: left;"><strong>Key Binding</strong></td><td style="text-align: left;"><strong>Description</strong></td></tr><tr class="even"><td style="text-align: left;"><code>: d</code></td><td style="text-align: left;">Decrypt marked or selected</td></tr><tr class="odd"><td style="text-align: left;"><code>: e</code></td><td style="text-align: left;">Encrypt marked or selected</td></tr><tr class="even"><td style="text-align: left;"><code>: s</code></td><td style="text-align: left;">Sign marked or selected</td></tr><tr class="odd"><td style="text-align: left;"><code>: v</code></td><td style="text-align: left;">Signs the current buffer</td></tr></tbody></table><p class=" text-justify">Dired is clever enough to apply the command to multiple files if you have marked files; if you don’t, it will use the file point is on.</p><p class=" text-justify">Keep in mind that if you want to encrypt multiple files into one <code>.gpg</code> file you will have to compress them first: press <code>c</code> then enter the target filename Emacs should compress the marked files to. Emacs will pick the right compression that matches the file extension (<code>.tar.gz</code>, <code>.zip</code>, etc.) and <em>then</em> you can encrypt the archive.</p><H3 id="disabling-external-pin-entry">Disabling External Pin Entry</H3><p class=" text-justify">You can force GPG to not use an external tool for pin entry. That is particularly useful if you don’t want the default GPG Agent pin entry tool to start, particularly if you want Emacs to handle the pin entry for you.</p><p class=" text-justify">There are probably many ways of doing this (as it’s likely to depend on your distro and window manager) but the easiest thing to do is disable the agent info in <em>Emacs</em> only:</p><pre><code>(setenv "GPG_AGENT_INFO" nil)</code></pre><p class=" text-justify">This will force Emacs to use its own internal password prompt instead of an external pin entry program.</p><H4 id="using-keys-to-store-secrets">Using Keys to Store Secrets</H4><p class=" text-justify"><em>NOTE: Please keep in mind that you are taking security advice from an Emacs blogger and not a security maven. The instructions below are just a guideline to show you how to use Emacs’s GPG integration.</em></p><p class=" text-justify">Like I mentioned above, it’s easy to transparently decrypt and encrypt files with a symmetric key but that’s an awful lot of hassle when you can use a public-private key pair instead. The benefit of the key is that you can keep it loaded into memory and let Emacs decrypt and re-encrypt files without prompting you for a password.</p><H3 id="creating-a-key">Creating a key</H3><p class=" text-justify">To get started you must first generate the key pair with <code>gpg</code>:</p><pre><code>$ gpg --gen-key</code></pre><p class=" text-justify">Follow the prompts to generate your key. I highly recommend you pick a pass phrase!</p><p class=" text-justify">You can verify it is loaded into your system’s keychain by running:</p><p class=" text-justify"><code>M-x epa-list-secret-keys</code> in Emacs;</p><p class=" text-justify">or <code>gpg --list-secret-keys</code> on your command line, in which case it’ll look like this:</p><pre><code>$ gpg --list-secret-keys

sec   2048R/5DB69AC1 2016-06-13
uid                  Cosmo Kramer (Kramerica Industries) &lt;kramer@example.com&gt;
ssb   2048R/02A89A28 2016-06-13</code></pre><p class=" text-justify">or using a UI program like <code>seahorse</code>.</p><H3 id="exporting-and-re-importing-a-key">Exporting and Re-Importing a Key</H3><p class=" text-justify">Next, export the secret key to a file <code>mykey.asc</code> to <code>gpg</code> (using the key holder’s name, email or key ID):</p><pre><code>$ gpg --armor --export-secret-keys Cosmo Kramer &gt; mykey.asc</code></pre><p class=" text-justify">You can now, on a different machine, re-import the key, but you will also have to <em>trust</em> it again. You can pass the full name in quotes or the e-mail to <code>gpg</code> and it will pick the right one. Here I edit a key based on the full name of the key holder and GPG is smart enough to figure out which one it is:</p><pre><code>$ gpg --import mykey.asc
$ gpg --edit-key "Cosmo Kramer"
gpg&gt; trust
Your decision? 5
Do you really want to set this key to ultimate trust? (y/N) y
gpg&gt; quit</code></pre><p class=" text-justify">At this point you have a key and a way of exporting and re-importing it between computers; useful, if you use more than one, but optional. It goes without saying that if you lose your key you lose your encrypted data!</p><H4 id="encrypting-data-with-a-key">Encrypting Data with a Key</H4><p class=" text-justify">Armed with a key you can tell <em>EasyPG</em> that it should simply decrypt and re-encrypt with the secret keys in your keychain. There’s a special <em>file local variable</em> called <code>epa-file-encrypt-to</code> that automatically picks the right key.</p><p class=" text-justify">Here’s a simple example. Create an elisp file <code>your-secrets.el</code> and enter the following:</p><pre><code># -*- epa-file-encrypt-to: ("kramer@example.com") -*-

(setq jabber-account-list ...)
(setq my-secret-password "rosebud")</code></pre><p class=" text-justify">Where <code>kramer@example.com</code> is the example key we created earlier and the e-mail “recipient” we encrypt and decrypt against. Observe that we are finding a key based on the e-mail address alone as it’s human readable as opposed to an ID. Next, explicitly encrypt it with <code>M-x epa-encrypt-file</code> and select the same key to encrypt with. When you try to save the encrypted file Emacs will automatically pick the right key.</p><p class=" text-justify">Now you can load the file in your <code>init.el</code> when you load Emacs:</p><pre><code>(load-library "/path/to/your-secrets.el.gpg")</code></pre><p class=" text-justify">Emacs will ask for a pass phrase of the key it was encrypted with and then load the elisp file as though it were a normal file.</p><H2 id="storing-credentials-with-the-auth-source-package">Storing Credentials with the Auth Source Package</H2><p class=" text-justify"><em>This chapter builds on information in the section Using Keys to Store Secrets.</em></p><p class=" text-justify">Auth Source is a generic interface for common backends such as your operating system’s Keychain and your local <code>~/.authinfo</code> or <code>~/.netrc</code> file.</p><p class=" text-justify">Auth Source is supported by a variety of Emacs packages, but with the added benefit of having a fairly straightforward API if you do need to call it directly. Among the supported ones are: <code>jabber.el</code>, GNUS, TRAMP, various internal network functions, LDAP (yes, Emacs has an LDAP client built in), and ERC.</p><p class=" text-justify">Auth Source solves the problem of mapping passwords and usernames to hosts, and it even supports multiple backends if you have credentials in more than one place.</p><H4 id="debugging-authentication-issues">Debugging Authentication Issues</H4><p class=" text-justify">The first thing I want to mention is the debug variable. Debugging authentication problems is hard enough without adding another layer inbetween. To enable debug information set the <code>auth-source-debug</code> to <code>t</code> to enable or <code>nil</code> to disable:</p><pre><code>(setq auth-source-debug t)</code></pre><p class=" text-justify">This will echo a lot of additional, helpful, information to the <code>*Messages*</code> buffer. Be sure to turn it off when you are done.</p><p class=" text-justify">Another useful function to call is <code>M-x auth-source-forget-all-cached</code>. Auth source will cache your credentials in Emacs; use this command to forget all the cached details.</p><H4 id="automatic-jabber-login">Automatic Jabber Login</H4><p class=" text-justify">Here’s a common workflow: logging in to Google Hangouts/Chat with <code>jabber.el</code>.</p><p class=" text-justify">Consider the following jabber account:</p><pre><code>(setq jabber-account-list
      '(("&lt;your-gmail-email&gt;"
         (:network-server . "talk.google.com")
         (:port . 443)
         (:connection-type . ssl))))</code></pre><p class=" text-justify">When you run <code>M-x jabber-connect</code> you’ll be asked – if all goes well – for your password. Instead of having to type it every time you can store it encrypted on your filesystem and have Emacs fill it in automatically.</p><p class=" text-justify">To do this we’ll need an <code>.authinfo</code> file and a way of telling Emacs where it is. By default it will look in <code>~/.authinfo</code> and a few other places, but I prefer keeping it encrypted and under source control. So to tell <code>auth-source</code> where to look for it you update the <code>auth-sources</code> list variable:</p><pre><code>(setq auth-sources
    '((:source "~/.emacs.d/secrets/.authinfo.gpg")))</code></pre><p class=" text-justify">Change the filepath to one that works for you. Next, create the empty file as <code>.authinfo.gpg</code> and add this line:</p><pre><code>machine gmail.com login &lt;your account name&gt; port xmpp password &lt;your secret password&gt;</code></pre><p class=" text-justify">Replacing <code>&lt;your account name&gt;</code> with the username <em>only</em> – i.e., <code>johndoe</code> and not <code>johndoe@gmail.com</code>. Replace <code>&lt;your secret password&gt;</code> with your password and save the file and pick the key you created earlier.</p><p class=" text-justify">Ensure the <code>auth-sources</code> variable is set up and evaluated and then run <code>M-x jabber-connect</code> again and – if you’ve set it up right – Emacs will decrypt your <code>.authinfo.gpg</code> file – prompting you for your passphrase, once, if Emacs does not have the secret key in memory – and match the hostname and username against the entries in <code>.authinfo.gpg</code> and send the password to Jabber.</p><p class=" text-justify">And if things go wrong, refer to the <em>Debugging Authentication Issues</em> chapter above.</p><p class=" text-justify">Now you can go ahead and extend this to your e-mails, to TRAMP (if you don’t use SSH keys) and so on applying the same principles. Emacs will keep the secret key in memory and apply it automatically and you won’t be badgered to enter a password over and over again any more.</p><p class=" text-justify">One more useful thing about the <code>auth-sources</code> variable: you can have more than one source. You can even use your OS’s keychain/agent as a source of keys.</p><H2 id="conclusion">Conclusion</H2><p class=" text-justify">Good news – your Vogon poetry’s safe. As you can see, with a bit of technical kowtowing with GPG and Emacs’s authentication machinery and you can automate away most of the tedium of credentials management. <em>EasyPG</em> and <em>Auth Sources</em> are both powerful tools that you should learn more about. In fact, I’ve barely scratched the surface and, like all things Emacs, everyone has their own special snowflake configuration so do let me know if you can think of interesting, time-saving workflows.</p>
